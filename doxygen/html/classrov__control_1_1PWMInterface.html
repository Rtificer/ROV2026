<!-- HTML header for doxygen 1.9.8-->
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
  <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=11" />
  <meta name="generator" content="Doxygen 1.9.8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>ROV2026: rov_control::PWMInterface Class Reference</title>
  <link href="tabs.css" rel="stylesheet" type="text/css" />
  <script type="text/javascript" src="jquery.js"></script>
  <script type="text/javascript" src="dynsections.js"></script>
  <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
  <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
  <script type="text/javascript" src="darkmode_toggle.js"></script>
  <link href="doxygen.css" rel="stylesheet" type="text/css" />
  <link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
  <script type="text/javascript">
    // Force dark mode as default if no preference is set
    if (window.matchMedia && !localStorage.getItem('doxygen-awesome-dark-mode')) {
      if (!window.matchMedia('(prefers-color-scheme: dark)').matches) {
        localStorage.setItem('doxygen-awesome-dark-mode', 'dark');
      }
    }
  </script>
  <script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
  <script type="text/javascript">
    DoxygenAwesomeDarkModeToggle.init()
  </script>
</head>
<body>
    <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
      <div id="titlearea">
        <table cellspacing="0" cellpadding="0">
          <tbody>
            <tr id="projectrow">
              <td id="projectalign">
                <div id="projectname">ROV2026
                </div>
              </td>
            </tr>
          </tbody>
        </table>
      </div>
      <!-- end header part --><!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classrov__control_1_1PWMInterface.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classrov__control_1_1PWMInterface-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">rov_control::PWMInterface Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="pwm__interface_8hpp_source.html">pwm_interface.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for rov_control::PWMInterface:</div>
<div class="dyncontent">
<div class="center"><img src="classrov__control_1_1PWMInterface__inherit__graph.png" border="0" usemap="#arov__control_1_1PWMInterface_inherit__map" alt="Inheritance graph"/></div>
<map name="arov__control_1_1PWMInterface_inherit__map" id="arov__control_1_1PWMInterface_inherit__map">
<area shape="rect" title=" " alt="" coords="5,93,200,119"/>
<area shape="rect" title=" " alt="" coords="29,5,177,45"/>
<area shape="poly" title=" " alt="" coords="105,59,105,93,100,93,100,59"/>
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for rov_control::PWMInterface:</div>
<div class="dyncontent">
<div class="center"><img src="classrov__control_1_1PWMInterface__coll__graph.png" border="0" usemap="#arov__control_1_1PWMInterface_coll__map" alt="Collaboration graph"/></div>
<map name="arov__control_1_1PWMInterface_coll__map" id="arov__control_1_1PWMInterface_coll__map">
<area shape="rect" title=" " alt="" coords="5,93,200,119"/>
<area shape="rect" title=" " alt="" coords="29,5,177,45"/>
<area shape="poly" title=" " alt="" coords="105,59,105,93,100,93,100,59"/>
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a50da806c99d97dbc89eb78d8ae1d4fb8" id="r_a50da806c99d97dbc89eb78d8ae1d4fb8"><td class="memItemLeft" align="right" valign="top">hardware_interface::CallbackReturn&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrov__control_1_1PWMInterface.html#a50da806c99d97dbc89eb78d8ae1d4fb8">on_init</a> (const hardware_interface::HardwareInfo &amp;info) override</td></tr>
<tr class="memdesc:a50da806c99d97dbc89eb78d8ae1d4fb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the pwm hardware interface with hardware information.  <br /></td></tr>
<tr class="separator:a50da806c99d97dbc89eb78d8ae1d4fb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53df8cbe968e423fceeb5198ca6db18c" id="r_a53df8cbe968e423fceeb5198ca6db18c"><td class="memItemLeft" align="right" valign="top">std::vector&lt; hardware_interface::StateInterface &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrov__control_1_1PWMInterface.html#a53df8cbe968e423fceeb5198ca6db18c">export_state_interfaces</a> () override</td></tr>
<tr class="memdesc:a53df8cbe968e423fceeb5198ca6db18c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Export state interfaces for the pwm hardware.  <br /></td></tr>
<tr class="separator:a53df8cbe968e423fceeb5198ca6db18c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52dc453fa4874b2dd39e46f1611ba3aa" id="r_a52dc453fa4874b2dd39e46f1611ba3aa"><td class="memItemLeft" align="right" valign="top">std::vector&lt; hardware_interface::CommandInterface &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrov__control_1_1PWMInterface.html#a52dc453fa4874b2dd39e46f1611ba3aa">export_command_interfaces</a> () override</td></tr>
<tr class="memdesc:a52dc453fa4874b2dd39e46f1611ba3aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Export command interfaces for the pwm hardware.  <br /></td></tr>
<tr class="separator:a52dc453fa4874b2dd39e46f1611ba3aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad04db75eaa1f5425fcda2133337cebb0" id="r_ad04db75eaa1f5425fcda2133337cebb0"><td class="memItemLeft" align="right" valign="top">hardware_interface::return_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrov__control_1_1PWMInterface.html#ad04db75eaa1f5425fcda2133337cebb0">read</a> (const rclcpp::Time &amp;time, const rclcpp::Duration &amp;period) override</td></tr>
<tr class="memdesc:ad04db75eaa1f5425fcda2133337cebb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the current state of the pwm hardware.  <br /></td></tr>
<tr class="separator:ad04db75eaa1f5425fcda2133337cebb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49f2e6cc79c5fdbddfb3ed90b5b1c190" id="r_a49f2e6cc79c5fdbddfb3ed90b5b1c190"><td class="memItemLeft" align="right" valign="top">hardware_interface::return_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrov__control_1_1PWMInterface.html#a49f2e6cc79c5fdbddfb3ed90b5b1c190">write</a> (const rclcpp::Time &amp;time, const rclcpp::Duration &amp;period) override</td></tr>
<tr class="memdesc:a49f2e6cc79c5fdbddfb3ed90b5b1c190"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the current command values to the pwm hardware.  <br /></td></tr>
<tr class="separator:a49f2e6cc79c5fdbddfb3ed90b5b1c190"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3474724b6eac30fd729b8ff1298df00" id="r_af3474724b6eac30fd729b8ff1298df00"><td class="memItemLeft" align="right" valign="top">hardware_interface::CallbackReturn&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrov__control_1_1PWMInterface.html#af3474724b6eac30fd729b8ff1298df00">on_configure</a> ()</td></tr>
<tr class="memdesc:af3474724b6eac30fd729b8ff1298df00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure the pwm hardware interface.  <br /></td></tr>
<tr class="separator:af3474724b6eac30fd729b8ff1298df00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bde60e13810ff40b04b2578f8878621" id="r_a3bde60e13810ff40b04b2578f8878621"><td class="memItemLeft" align="right" valign="top">hardware_interface::CallbackReturn&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrov__control_1_1PWMInterface.html#a3bde60e13810ff40b04b2578f8878621">on_cleanup</a> ()</td></tr>
<tr class="memdesc:a3bde60e13810ff40b04b2578f8878621"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cleanup the pwm hardware interface.  <br /></td></tr>
<tr class="separator:a3bde60e13810ff40b04b2578f8878621"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7738632dace0d852f7149860a37bfac0" id="r_a7738632dace0d852f7149860a37bfac0"><td class="memItemLeft" align="right" valign="top">hardware_interface::CallbackReturn&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrov__control_1_1PWMInterface.html#a7738632dace0d852f7149860a37bfac0">on_shutdown</a> ()</td></tr>
<tr class="memdesc:a7738632dace0d852f7149860a37bfac0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shutdown the pwm hardware interface.  <br /></td></tr>
<tr class="separator:a7738632dace0d852f7149860a37bfac0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaea2943e8203604494d48335f4b5f9f6" id="r_aaea2943e8203604494d48335f4b5f9f6"><td class="memItemLeft" align="right" valign="top">hardware_interface::CallbackReturn&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrov__control_1_1PWMInterface.html#aaea2943e8203604494d48335f4b5f9f6">on_activate</a> ()</td></tr>
<tr class="memdesc:aaea2943e8203604494d48335f4b5f9f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Activate the pwm hardware interface.  <br /></td></tr>
<tr class="separator:aaea2943e8203604494d48335f4b5f9f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5331dc30690826b7c5d675b9b78766e1" id="r_a5331dc30690826b7c5d675b9b78766e1"><td class="memItemLeft" align="right" valign="top">hardware_interface::CallbackReturn&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrov__control_1_1PWMInterface.html#a5331dc30690826b7c5d675b9b78766e1">on_deactivate</a> ()</td></tr>
<tr class="memdesc:a5331dc30690826b7c5d675b9b78766e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deactivate the pwm hardware interface.  <br /></td></tr>
<tr class="separator:a5331dc30690826b7c5d675b9b78766e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ff8316085c1e00e5e7be256547c337b" id="r_a3ff8316085c1e00e5e7be256547c337b"><td class="memItemLeft" align="right" valign="top">hardware_interface::CallbackReturn&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrov__control_1_1PWMInterface.html#a3ff8316085c1e00e5e7be256547c337b">on_error</a> ()</td></tr>
<tr class="memdesc:a3ff8316085c1e00e5e7be256547c337b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handle error state for the pwm hardware interface.  <br /></td></tr>
<tr class="separator:a3ff8316085c1e00e5e7be256547c337b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-methods" name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a5f150a0ff93daea01c185b12fc429790" id="r_a5f150a0ff93daea01c185b12fc429790"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrov__control_1_1PWMInterface.html#a5f150a0ff93daea01c185b12fc429790">load_parameters</a> (const hardware_interface::HardwareInfo &amp;info)</td></tr>
<tr class="memdesc:a5f150a0ff93daea01c185b12fc429790"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads hardware info.  <br /></td></tr>
<tr class="separator:a5f150a0ff93daea01c185b12fc429790"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71cd8378d02ebfd2ac4a320ac62092d4" id="r_a71cd8378d02ebfd2ac4a320ac62092d4"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrov__control_1_1PWMInterface.html#a71cd8378d02ebfd2ac4a320ac62092d4">command_to_ticks</a> (double command, uint16_t pwm_min_µs, uint16_t pwm_max_µs, uint16_t pwm_mid_µs, uint16_t pwm_freq_hz)</td></tr>
<tr class="memdesc:a71cd8378d02ebfd2ac4a320ac62092d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a normalized pwm command to PCA9685 ticks.  <br /></td></tr>
<tr class="separator:a71cd8378d02ebfd2ac4a320ac62092d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-attribs" name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a0a5ec476f7fda4d541dc35983cb6965f" id="r_a0a5ec476f7fda4d541dc35983cb6965f"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrov__control_1_1PWMInterface.html#a0a5ec476f7fda4d541dc35983cb6965f">command_</a></td></tr>
<tr class="separator:a0a5ec476f7fda4d541dc35983cb6965f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f207b516495acedd3650ad285e29aa0" id="r_a2f207b516495acedd3650ad285e29aa0"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrov__control_1_1PWMInterface.html#a2f207b516495acedd3650ad285e29aa0">state_</a></td></tr>
<tr class="separator:a2f207b516495acedd3650ad285e29aa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8061d34f799b836f5790bb1d6fad6fff" id="r_a8061d34f799b836f5790bb1d6fad6fff"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrov__control_1_1PWMInterface.html#a8061d34f799b836f5790bb1d6fad6fff">pwm_freq_hz_</a> {50}</td></tr>
<tr class="separator:a8061d34f799b836f5790bb1d6fad6fff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42a6fbb5923998fb0857ac8551865919" id="r_a42a6fbb5923998fb0857ac8551865919"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrov__control_1_1PWMInterface.html#a42a6fbb5923998fb0857ac8551865919">pwm_min_µs_</a> {1000}</td></tr>
<tr class="separator:a42a6fbb5923998fb0857ac8551865919"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac576d3b99106895df90956551d63da6c" id="r_ac576d3b99106895df90956551d63da6c"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrov__control_1_1PWMInterface.html#ac576d3b99106895df90956551d63da6c">pwm_max_µs_</a> {2000}</td></tr>
<tr class="separator:ac576d3b99106895df90956551d63da6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bc4a1f92b3ee9e84d6b6f359b5e37ee" id="r_a5bc4a1f92b3ee9e84d6b6f359b5e37ee"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrov__control_1_1PWMInterface.html#a5bc4a1f92b3ee9e84d6b6f359b5e37ee">pwm_mid_µs_</a> {1500}</td></tr>
<tr class="separator:a5bc4a1f92b3ee9e84d6b6f359b5e37ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a71cd8378d02ebfd2ac4a320ac62092d4" name="a71cd8378d02ebfd2ac4a320ac62092d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71cd8378d02ebfd2ac4a320ac62092d4">&#9670;&#160;</a></span>command_to_ticks()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t rov_control::PWMInterface::command_to_ticks </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>command</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>pwm_min_µs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>pwm_max_µs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>pwm_mid_µs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>pwm_freq_hz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a normalized pwm command to PCA9685 ticks. </p>
<p>This function maps a normalized command value (-1 to 1) to a PWM pulse width in microseconds, then converts that pulse width to PCA9685 ticks. The mapping uses the configured minimum, maximum, and midpoint pulse widths.</p>
<p>The mapping formula is: pulse_µs = pwm_mid_µs + command * (command &gt;= 0 ? (pwm_max_µs - pwm_mid_µs) : (pwm_mid_µs - pwm_min_µs))</p>
<ul>
<li>For command = 0.0, returns the midpoint pulse width (neutral/stop).</li>
<li>For command &gt; 0.0, linearly interpolates between midpoint and maximum (forward thrust).</li>
<li>For command &lt; 0.0, linearly interpolates between midpoint and minimum (reverse thrust).</li>
<li>The command value is clamped to [-1.0, 1.0] for safety.</li>
</ul>
<p>For our Blue Robotics Basic ESCs, and with most other ESCs, the mapping is:</p><ul>
<li>Minimum pulse (e.g., 1100 µs) = full reverse</li>
<li>Midpoint pulse (e.g., 1500 µs) = stop</li>
<li>Maximum pulse (e.g., 1900 µs) = full forward</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">command</td><td>The normalized pwm command [-1.0, 1.0]. </td></tr>
    <tr><td class="paramname">pwm_min_µs</td><td>Minimum pulse width in microseconds. </td></tr>
    <tr><td class="paramname">pwm_max_µs</td><td>Maximum pulse width in microseconds. </td></tr>
    <tr><td class="paramname">pwm_mid_µs</td><td>Midpoint pulse width in microseconds. </td></tr>
    <tr><td class="paramname">pwm_freq_hz</td><td>PWM frequency in Hertz. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of PCA9685 ticks corresponding to the command. </dd></dl>

</div>
</div>
<a id="a52dc453fa4874b2dd39e46f1611ba3aa" name="a52dc453fa4874b2dd39e46f1611ba3aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52dc453fa4874b2dd39e46f1611ba3aa">&#9670;&#160;</a></span>export_command_interfaces()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; hardware_interface::CommandInterface &gt; rov_control::PWMInterface::export_command_interfaces </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Export command interfaces for the pwm hardware. </p>
<p>This method creates and returns a vector of command interfaces for each pwm joint, as defined in the description/urdf/ROV2026.urdf.xacro. Each interface allows the ROS 2 control framework to send command values to the corresponding pwm component.</p>
<dl class="section return"><dt>Returns</dt><dd>std::vector&lt;hardware_interface::CommandInterface&gt; A vector containing the command interfaces for all pwm components. </dd></dl>

</div>
</div>
<a id="a53df8cbe968e423fceeb5198ca6db18c" name="a53df8cbe968e423fceeb5198ca6db18c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53df8cbe968e423fceeb5198ca6db18c">&#9670;&#160;</a></span>export_state_interfaces()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; hardware_interface::StateInterface &gt; rov_control::PWMInterface::export_state_interfaces </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Export state interfaces for the pwm hardware. </p>
<p>This method creates and returns a vector of state interfaces for each pwm joint, as defined in the description/urdf/ROV2026.urdf.xacro. Each interface allows the ROS 2 control framework to read the current effort (state) values from the corresponding pwm component.</p>
<dl class="section return"><dt>Returns</dt><dd>std::vector&lt;hardware_interface::StateInterface&gt; A vector containing the state interfaces for all pwm components. </dd></dl>

</div>
</div>
<a id="a5f150a0ff93daea01c185b12fc429790" name="a5f150a0ff93daea01c185b12fc429790"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f150a0ff93daea01c185b12fc429790">&#9670;&#160;</a></span>load_parameters()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void rov_control::PWMInterface::load_parameters </td>
          <td>(</td>
          <td class="paramtype">const hardware_interface::HardwareInfo &amp;&#160;</td>
          <td class="paramname"><em>info</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loads hardware info. </p>
<p>This method reads the PWM-related parameters (frequency, minimum, maximum, and midpoint pulse widths) from the provided hardware_interface::HardwareInfo structure. If a parameter is present in the hardware parameters map, its value is parsed and assigned to the corresponding member variable. If a parameter is not present, the existing value (typically the default) is retained.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">info</td><td>The hardware information structure containing hardware parameters. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaea2943e8203604494d48335f4b5f9f6" name="aaea2943e8203604494d48335f4b5f9f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaea2943e8203604494d48335f4b5f9f6">&#9670;&#160;</a></span>on_activate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">hardware_interface::CallbackReturn rov_control::PWMInterface::on_activate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Activate the pwm hardware interface. </p>
<p>This method is called during the transition from the inactive state to the active state in the ROS 2 lifecycle. It is responsible for preparing the hardware interface to start accepting and executing commands. TODO: Activate or enable hardware.</p>
<dl class="section return"><dt>Returns</dt><dd>hardware_interface::CallbackReturn Returns SUCCESS if activation was successful, ERROR otherwise. </dd></dl>

</div>
</div>
<a id="a3bde60e13810ff40b04b2578f8878621" name="a3bde60e13810ff40b04b2578f8878621"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bde60e13810ff40b04b2578f8878621">&#9670;&#160;</a></span>on_cleanup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">hardware_interface::CallbackReturn rov_control::PWMInterface::on_cleanup </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cleanup the pwm hardware interface. </p>
<p>This method is called during the transition from the inactive state to the unconfigured state in the ROS 2 lifecycle. It resets the command and state vectors to zero and releases any resources allocated during configuration or activation. This prepares the hardware interface for possible reconfiguration or safe shutdown. TODO: Cleanup or release hardware resources in preparation for reconfiguration or shutdown.</p>
<dl class="section return"><dt>Returns</dt><dd>hardware_interface::CallbackReturn Returns SUCCESS if cleanup was successful, ERROR otherwise. </dd></dl>

</div>
</div>
<a id="af3474724b6eac30fd729b8ff1298df00" name="af3474724b6eac30fd729b8ff1298df00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3474724b6eac30fd729b8ff1298df00">&#9670;&#160;</a></span>on_configure()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">hardware_interface::CallbackReturn rov_control::PWMInterface::on_configure </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure the pwm hardware interface. </p>
<p>This method is called during the transition from the unconfigured state to the inactive state in the ROS 2 lifecycle. It resets the command and state vectors to zero and prepares the hardware interface for activation. TODO: Initialization or setup hardware required before activation.</p>
<dl class="section return"><dt>Returns</dt><dd>hardware_interface::CallbackReturn Returns SUCCESS if configuration was successful, ERROR otherwise. </dd></dl>

</div>
</div>
<a id="a5331dc30690826b7c5d675b9b78766e1" name="a5331dc30690826b7c5d675b9b78766e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5331dc30690826b7c5d675b9b78766e1">&#9670;&#160;</a></span>on_deactivate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">hardware_interface::CallbackReturn rov_control::PWMInterface::on_deactivate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deactivate the pwm hardware interface. </p>
<p>This method is called during the transition from the active state to the inactive state in the ROS 2 lifecycle. It is responsible for stopping the hardware interface from accepting and executing commands. We reset the state and command vectors to zero to ensure safe deactivation. TODO: Deactivate or disable hardware.</p>
<dl class="section return"><dt>Returns</dt><dd>hardware_interface::CallbackReturn Returns SUCCESS if deactivation was successful, ERROR otherwise. </dd></dl>

</div>
</div>
<a id="a3ff8316085c1e00e5e7be256547c337b" name="a3ff8316085c1e00e5e7be256547c337b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ff8316085c1e00e5e7be256547c337b">&#9670;&#160;</a></span>on_error()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">hardware_interface::CallbackReturn rov_control::PWMInterface::on_error </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Handle error state for the pwm hardware interface. </p>
<p>This method is called when the hardware interface enters the error state in the ROS 2 lifecycle. It is responsible for putting the hardware into a safe state, such as stopping all pwm compoents by setting the command and state vectors to zero, and logging the error. This ensures that the hardware does not continue operating in an unsafe or undefined state after an error has occurred.</p>
<dl class="section return"><dt>Returns</dt><dd>hardware_interface::CallbackReturn Returns ERROR to indicate the hardware is in an error state. </dd></dl>

</div>
</div>
<a id="a50da806c99d97dbc89eb78d8ae1d4fb8" name="a50da806c99d97dbc89eb78d8ae1d4fb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50da806c99d97dbc89eb78d8ae1d4fb8">&#9670;&#160;</a></span>on_init()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">hardware_interface::CallbackReturn rov_control::PWMInterface::on_init </td>
          <td>(</td>
          <td class="paramtype">const hardware_interface::HardwareInfo &amp;&#160;</td>
          <td class="paramname"><em>info</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize the pwm hardware interface with hardware information. </p>
<p>This method is called during the initialization phase of the hardware interface lifecycle. It checks if all required parameters are set and valid by calling the base class implementation. If successful, it initializes the command and state vectors to zero, with a length equal to the number of pwm joints.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">info</td><td>The hardware information structure containing joint and interface definitions. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>hardware_interface::CallbackReturn Returns SUCCESS if initialization was successful, ERROR otherwise. </dd></dl>

</div>
</div>
<a id="a7738632dace0d852f7149860a37bfac0" name="a7738632dace0d852f7149860a37bfac0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7738632dace0d852f7149860a37bfac0">&#9670;&#160;</a></span>on_shutdown()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">hardware_interface::CallbackReturn rov_control::PWMInterface::on_shutdown </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shutdown the pwm hardware interface. </p>
<p>This method is called during the transition to the finalized (shutdown) state in the ROS 2 lifecycle. It is responsible for safely stopping all pwm components, releasing hardware resources, and resetting the command and state vectors to zero. This ensures the hardware is left in a safe state before the node is destroyed or the process exits. TODO: Shutdown hardware.</p>
<dl class="section return"><dt>Returns</dt><dd>hardware_interface::CallbackReturn Returns SUCCESS if shutdown was successful, ERROR otherwise. </dd></dl>

</div>
</div>
<a id="ad04db75eaa1f5425fcda2133337cebb0" name="ad04db75eaa1f5425fcda2133337cebb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad04db75eaa1f5425fcda2133337cebb0">&#9670;&#160;</a></span>read()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">hardware_interface::return_type rov_control::PWMInterface::read </td>
          <td>(</td>
          <td class="paramtype">const rclcpp::Time &amp;&#160;</td>
          <td class="paramname"><em>time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const rclcpp::Duration &amp;&#160;</td>
          <td class="paramname"><em>period</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read the current state of the pwm hardware. </p>
<p>This method updates the internal state vector to reflect the current state of each pwm component.</p>
<dl class="section return"><dt>Returns</dt><dd>hardware_interface::return_type Returns OK after updating the state. </dd></dl>

</div>
</div>
<a id="a49f2e6cc79c5fdbddfb3ed90b5b1c190" name="a49f2e6cc79c5fdbddfb3ed90b5b1c190"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49f2e6cc79c5fdbddfb3ed90b5b1c190">&#9670;&#160;</a></span>write()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">hardware_interface::return_type rov_control::PWMInterface::write </td>
          <td>(</td>
          <td class="paramtype">const rclcpp::Time &amp;&#160;</td>
          <td class="paramname"><em>time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const rclcpp::Duration &amp;&#160;</td>
          <td class="paramname"><em>period</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write the current command values to the pwm hardware. </p>
<p>This method sends the command values stored in the internal command vector to each pwm component. For each pwm component, the corresponding command value is converted to PCA9685 ticks using the configured PWM parameters (min, max, mid pulse widths, and frequency). The pulse is always set to start at the beginning of the PWM cycle (on=0), and the width is set by the calculated ticks value (off=ticks).</p>
<p>The function calls pca9685_write_channel() for each pwm channel:</p><ul>
<li>The third argument (on=0) means the PWM pulse starts at the beginning of the cycle.</li>
<li>The fourth argument (off=ticks) sets the pulse width. If writing to any channel fails, an error is logged and the function returns ERROR. Otherwise, it logs the command sent to each pwm component and returns OK.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>hardware_interface::return_type Returns OK after sending the commands, or ERROR if any write fails. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a0a5ec476f7fda4d541dc35983cb6965f" name="a0a5ec476f7fda4d541dc35983cb6965f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a5ec476f7fda4d541dc35983cb6965f">&#9670;&#160;</a></span>command_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;double&gt; rov_control::PWMInterface::command_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8061d34f799b836f5790bb1d6fad6fff" name="a8061d34f799b836f5790bb1d6fad6fff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8061d34f799b836f5790bb1d6fad6fff">&#9670;&#160;</a></span>pwm_freq_hz_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t rov_control::PWMInterface::pwm_freq_hz_ {50}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac576d3b99106895df90956551d63da6c" name="ac576d3b99106895df90956551d63da6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac576d3b99106895df90956551d63da6c">&#9670;&#160;</a></span>pwm_max_µs_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t rov_control::PWMInterface::pwm_max_µs_ {2000}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5bc4a1f92b3ee9e84d6b6f359b5e37ee" name="a5bc4a1f92b3ee9e84d6b6f359b5e37ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bc4a1f92b3ee9e84d6b6f359b5e37ee">&#9670;&#160;</a></span>pwm_mid_µs_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t rov_control::PWMInterface::pwm_mid_µs_ {1500}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a42a6fbb5923998fb0857ac8551865919" name="a42a6fbb5923998fb0857ac8551865919"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42a6fbb5923998fb0857ac8551865919">&#9670;&#160;</a></span>pwm_min_µs_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t rov_control::PWMInterface::pwm_min_µs_ {1000}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2f207b516495acedd3650ad285e29aa0" name="a2f207b516495acedd3650ad285e29aa0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f207b516495acedd3650ad285e29aa0">&#9670;&#160;</a></span>state_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;double&gt; rov_control::PWMInterface::state_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>src/rov_control/include/rov_control/<a class="el" href="pwm__interface_8hpp_source.html">pwm_interface.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacerov__control.html">rov_control</a></li><li class="navelem"><a class="el" href="classrov__control_1_1PWMInterface.html">PWMInterface</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
