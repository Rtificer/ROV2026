<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ROV2026: rov_control::ThrusterHardwareInterface Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">ROV2026
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>rov_control</b></li><li class="navelem"><a class="el" href="classrov__control_1_1ThrusterHardwareInterface.html">ThrusterHardwareInterface</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classrov__control_1_1ThrusterHardwareInterface-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">rov_control::ThrusterHardwareInterface Class Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for rov_control::ThrusterHardwareInterface:</div>
<div class="dyncontent">
<div class="center"><img src="classrov__control_1_1ThrusterHardwareInterface__inherit__graph.png" border="0" usemap="#arov__control_1_1ThrusterHardwareInterface_inherit__map" alt="Inheritance graph"/></div>
<map name="arov__control_1_1ThrusterHardwareInterface_inherit__map" id="arov__control_1_1ThrusterHardwareInterface_inherit__map">
<area shape="rect" title=" " alt="" coords="5,93,225,133"/>
<area shape="rect" title=" " alt="" coords="41,5,189,45"/>
<area shape="poly" title=" " alt="" coords="118,59,118,93,113,93,113,59"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for rov_control::ThrusterHardwareInterface:</div>
<div class="dyncontent">
<div class="center"><img src="classrov__control_1_1ThrusterHardwareInterface__coll__graph.png" border="0" usemap="#arov__control_1_1ThrusterHardwareInterface_coll__map" alt="Collaboration graph"/></div>
<map name="arov__control_1_1ThrusterHardwareInterface_coll__map" id="arov__control_1_1ThrusterHardwareInterface_coll__map">
<area shape="rect" title=" " alt="" coords="5,93,225,133"/>
<area shape="rect" title=" " alt="" coords="41,5,189,45"/>
<area shape="poly" title=" " alt="" coords="118,59,118,93,113,93,113,59"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:abbd837b4d214cd05a40588212f4e74c9" id="r_abbd837b4d214cd05a40588212f4e74c9"><td class="memItemLeft" align="right" valign="top">hardware_interface::CallbackReturn&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrov__control_1_1ThrusterHardwareInterface.html#abbd837b4d214cd05a40588212f4e74c9">on_init</a> (const hardware_interface::HardwareInfo &amp;info) override</td></tr>
<tr class="memdesc:abbd837b4d214cd05a40588212f4e74c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the thruster hardware interface with hardware information.  <br /></td></tr>
<tr class="separator:abbd837b4d214cd05a40588212f4e74c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbe5e7fa69e2a24b7f78316406fd7b96" id="r_adbe5e7fa69e2a24b7f78316406fd7b96"><td class="memItemLeft" align="right" valign="top">std::vector&lt; hardware_interface::StateInterface &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrov__control_1_1ThrusterHardwareInterface.html#adbe5e7fa69e2a24b7f78316406fd7b96">export_state_interfaces</a> () override</td></tr>
<tr class="memdesc:adbe5e7fa69e2a24b7f78316406fd7b96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Export state interfaces for the thruster hardware.  <br /></td></tr>
<tr class="separator:adbe5e7fa69e2a24b7f78316406fd7b96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af788d1fdfac10670768bfdefc6ab09ce" id="r_af788d1fdfac10670768bfdefc6ab09ce"><td class="memItemLeft" align="right" valign="top">std::vector&lt; hardware_interface::CommandInterface &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrov__control_1_1ThrusterHardwareInterface.html#af788d1fdfac10670768bfdefc6ab09ce">export_command_interfaces</a> () override</td></tr>
<tr class="memdesc:af788d1fdfac10670768bfdefc6ab09ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Export command interfaces for the thruster hardware.  <br /></td></tr>
<tr class="separator:af788d1fdfac10670768bfdefc6ab09ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89faade16e301a5177e417bedcec840d" id="r_a89faade16e301a5177e417bedcec840d"><td class="memItemLeft" align="right" valign="top">hardware_interface::return_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrov__control_1_1ThrusterHardwareInterface.html#a89faade16e301a5177e417bedcec840d">read</a> ()</td></tr>
<tr class="memdesc:a89faade16e301a5177e417bedcec840d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the current state of the thruster hardware.  <br /></td></tr>
<tr class="separator:a89faade16e301a5177e417bedcec840d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1c4bb7d35ff1dfc0696c262d75a34c5" id="r_aa1c4bb7d35ff1dfc0696c262d75a34c5"><td class="memItemLeft" align="right" valign="top">hardware_interface::return_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrov__control_1_1ThrusterHardwareInterface.html#aa1c4bb7d35ff1dfc0696c262d75a34c5">write</a> ()</td></tr>
<tr class="memdesc:aa1c4bb7d35ff1dfc0696c262d75a34c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the current command values to the thruster hardware.  <br /></td></tr>
<tr class="separator:aa1c4bb7d35ff1dfc0696c262d75a34c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8265d068b0e73ab919e96f9bba57ebb1" id="r_a8265d068b0e73ab919e96f9bba57ebb1"><td class="memItemLeft" align="right" valign="top">hardware_interface::CallbackReturn&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrov__control_1_1ThrusterHardwareInterface.html#a8265d068b0e73ab919e96f9bba57ebb1">on_configure</a> ()</td></tr>
<tr class="memdesc:a8265d068b0e73ab919e96f9bba57ebb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure the thruster hardware interface.  <br /></td></tr>
<tr class="separator:a8265d068b0e73ab919e96f9bba57ebb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaad573b84f1eb13a0dba544a1da5089b" id="r_aaad573b84f1eb13a0dba544a1da5089b"><td class="memItemLeft" align="right" valign="top">hardware_interface::CallbackReturn&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrov__control_1_1ThrusterHardwareInterface.html#aaad573b84f1eb13a0dba544a1da5089b">on_cleanup</a> ()</td></tr>
<tr class="memdesc:aaad573b84f1eb13a0dba544a1da5089b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cleanup the thruster hardware interface.  <br /></td></tr>
<tr class="separator:aaad573b84f1eb13a0dba544a1da5089b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88696bfa332c2b6a308e83c246b0d080" id="r_a88696bfa332c2b6a308e83c246b0d080"><td class="memItemLeft" align="right" valign="top">hardware_interface::CallbackReturn&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrov__control_1_1ThrusterHardwareInterface.html#a88696bfa332c2b6a308e83c246b0d080">on_shutdown</a> ()</td></tr>
<tr class="memdesc:a88696bfa332c2b6a308e83c246b0d080"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shutdown the thruster hardware interface.  <br /></td></tr>
<tr class="separator:a88696bfa332c2b6a308e83c246b0d080"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dd7f1141ba64dc63975d973ecba7f15" id="r_a5dd7f1141ba64dc63975d973ecba7f15"><td class="memItemLeft" align="right" valign="top">hardware_interface::CallbackReturn&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrov__control_1_1ThrusterHardwareInterface.html#a5dd7f1141ba64dc63975d973ecba7f15">on_activate</a> ()</td></tr>
<tr class="memdesc:a5dd7f1141ba64dc63975d973ecba7f15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Activate the thruster hardware interface.  <br /></td></tr>
<tr class="separator:a5dd7f1141ba64dc63975d973ecba7f15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5d52c903b9006056b567a28fe402769" id="r_ad5d52c903b9006056b567a28fe402769"><td class="memItemLeft" align="right" valign="top">hardware_interface::CallbackReturn&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrov__control_1_1ThrusterHardwareInterface.html#ad5d52c903b9006056b567a28fe402769">on_deactivate</a> ()</td></tr>
<tr class="memdesc:ad5d52c903b9006056b567a28fe402769"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deactivate the thruster hardware interface.  <br /></td></tr>
<tr class="separator:ad5d52c903b9006056b567a28fe402769"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3dda9730f55662427cf3f09d1b57280" id="r_ac3dda9730f55662427cf3f09d1b57280"><td class="memItemLeft" align="right" valign="top">hardware_interface::CallbackReturn&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrov__control_1_1ThrusterHardwareInterface.html#ac3dda9730f55662427cf3f09d1b57280">on_error</a> ()</td></tr>
<tr class="memdesc:ac3dda9730f55662427cf3f09d1b57280"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handle error state for the thruster hardware interface.  <br /></td></tr>
<tr class="separator:ac3dda9730f55662427cf3f09d1b57280"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-methods" name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a2db88eeed2739b0ecac65e528a305b0e" id="r_a2db88eeed2739b0ecac65e528a305b0e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrov__control_1_1ThrusterHardwareInterface.html#a2db88eeed2739b0ecac65e528a305b0e">load_parameters</a> (const hardware_interface::HardwareInfo &amp;info)</td></tr>
<tr class="memdesc:a2db88eeed2739b0ecac65e528a305b0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads hardware info.  <br /></td></tr>
<tr class="separator:a2db88eeed2739b0ecac65e528a305b0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a309ae29b7dba32120bc94495eb59d1a3" id="r_a309ae29b7dba32120bc94495eb59d1a3"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrov__control_1_1ThrusterHardwareInterface.html#a309ae29b7dba32120bc94495eb59d1a3">command_to_ticks</a> (double command, uint16_t pwm_min_µs, uint16_t pwm_max_µs, uint16_t pwm_mid_µs, uint16_t pwm_freq_hz)</td></tr>
<tr class="memdesc:a309ae29b7dba32120bc94495eb59d1a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a normalized thruster command to PCA9685 ticks.  <br /></td></tr>
<tr class="separator:a309ae29b7dba32120bc94495eb59d1a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-attribs" name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a403ef6decbb4155bf4b52371eefdc26d" id="r_a403ef6decbb4155bf4b52371eefdc26d"><td class="memItemLeft" align="right" valign="top"><a id="a403ef6decbb4155bf4b52371eefdc26d" name="a403ef6decbb4155bf4b52371eefdc26d"></a>
std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>command_</b></td></tr>
<tr class="separator:a403ef6decbb4155bf4b52371eefdc26d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeae28f99a07740964f4bdebb9a20cc6e" id="r_aeae28f99a07740964f4bdebb9a20cc6e"><td class="memItemLeft" align="right" valign="top"><a id="aeae28f99a07740964f4bdebb9a20cc6e" name="aeae28f99a07740964f4bdebb9a20cc6e"></a>
std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>state_</b></td></tr>
<tr class="separator:aeae28f99a07740964f4bdebb9a20cc6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad89c674be786ee369ab97e40d6a65204" id="r_ad89c674be786ee369ab97e40d6a65204"><td class="memItemLeft" align="right" valign="top"><a id="ad89c674be786ee369ab97e40d6a65204" name="ad89c674be786ee369ab97e40d6a65204"></a>
uint16_t&#160;</td><td class="memItemRight" valign="bottom"><b>pwm_freq_hz_</b> {50}</td></tr>
<tr class="separator:ad89c674be786ee369ab97e40d6a65204"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5712c7e07706d29be5ae90ba2f5ad05" id="r_ab5712c7e07706d29be5ae90ba2f5ad05"><td class="memItemLeft" align="right" valign="top"><a id="ab5712c7e07706d29be5ae90ba2f5ad05" name="ab5712c7e07706d29be5ae90ba2f5ad05"></a>
uint16_t&#160;</td><td class="memItemRight" valign="bottom"><b>pwm_min_µs_</b> {1000}</td></tr>
<tr class="separator:ab5712c7e07706d29be5ae90ba2f5ad05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b0ae9ebd1d142f716976bda4d5fc7a8" id="r_a5b0ae9ebd1d142f716976bda4d5fc7a8"><td class="memItemLeft" align="right" valign="top"><a id="a5b0ae9ebd1d142f716976bda4d5fc7a8" name="a5b0ae9ebd1d142f716976bda4d5fc7a8"></a>
uint16_t&#160;</td><td class="memItemRight" valign="bottom"><b>pwm_max_µs_</b> {2000}</td></tr>
<tr class="separator:a5b0ae9ebd1d142f716976bda4d5fc7a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a235548f709524c6ca7443b54752095fc" id="r_a235548f709524c6ca7443b54752095fc"><td class="memItemLeft" align="right" valign="top"><a id="a235548f709524c6ca7443b54752095fc" name="a235548f709524c6ca7443b54752095fc"></a>
uint16_t&#160;</td><td class="memItemRight" valign="bottom"><b>pwm_mid_µs_</b> {1500}</td></tr>
<tr class="separator:a235548f709524c6ca7443b54752095fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a309ae29b7dba32120bc94495eb59d1a3" name="a309ae29b7dba32120bc94495eb59d1a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a309ae29b7dba32120bc94495eb59d1a3">&#9670;&#160;</a></span>command_to_ticks()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t rov_control::ThrusterHardwareInterface::command_to_ticks </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>command</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>pwm_min_µs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>pwm_max_µs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>pwm_mid_µs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>pwm_freq_hz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a normalized thruster command to PCA9685 ticks. </p>
<p>This function maps a normalized command value (-1 to 1) to a PWM pulse width in microseconds, then converts that pulse width to PCA9685 ticks. The mapping uses the configured minimum, maximum, and midpoint pulse widths.</p>
<p>The mapping formula is: pulse_µs = pwm_mid_µs + command * (command &gt;= 0 ? (pwm_max_µs - pwm_mid_µs) : (pwm_mid_µs - pwm_min_µs))</p>
<ul>
<li>For command = 0.0, returns the midpoint pulse width (neutral/stop).</li>
<li>For command &gt; 0.0, linearly interpolates between midpoint and maximum (forward thrust).</li>
<li>For command &lt; 0.0, linearly interpolates between midpoint and minimum (reverse thrust).</li>
<li>The command value is clamped to [-1.0, 1.0] for safety.</li>
</ul>
<p>For our Blue Robotics Basic ESCs, and with most other ESCs, the mapping is:</p><ul>
<li>Minimum pulse (e.g., 1100 µs) = full reverse</li>
<li>Midpoint pulse (e.g., 1500 µs) = stop</li>
<li>Maximum pulse (e.g., 1900 µs) = full forward</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">command</td><td>The normalized thruster command [-1.0, 1.0]. </td></tr>
    <tr><td class="paramname">pwm_min_µs</td><td>Minimum pulse width in microseconds. </td></tr>
    <tr><td class="paramname">pwm_max_µs</td><td>Maximum pulse width in microseconds. </td></tr>
    <tr><td class="paramname">pwm_mid_µs</td><td>Midpoint pulse width in microseconds. </td></tr>
    <tr><td class="paramname">pwm_freq_hz</td><td>PWM frequency in Hertz. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of PCA9685 ticks corresponding to the command. </dd></dl>

</div>
</div>
<a id="af788d1fdfac10670768bfdefc6ab09ce" name="af788d1fdfac10670768bfdefc6ab09ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af788d1fdfac10670768bfdefc6ab09ce">&#9670;&#160;</a></span>export_command_interfaces()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; hardware_interface::CommandInterface &gt; rov_control::ThrusterHardwareInterface::export_command_interfaces </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Export command interfaces for the thruster hardware. </p>
<p>This method creates and returns a vector of command interfaces for each thruster joint, as defined in the description/urdf/ROV2026.urdf.xacro. Each interface allows the ROS 2 control framework to send effort (command) values to the corresponding thruster.</p>
<dl class="section return"><dt>Returns</dt><dd>std::vector&lt;hardware_interface::CommandInterface&gt; A vector containing the command interfaces for all thrusters. </dd></dl>

</div>
</div>
<a id="adbe5e7fa69e2a24b7f78316406fd7b96" name="adbe5e7fa69e2a24b7f78316406fd7b96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbe5e7fa69e2a24b7f78316406fd7b96">&#9670;&#160;</a></span>export_state_interfaces()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; hardware_interface::StateInterface &gt; rov_control::ThrusterHardwareInterface::export_state_interfaces </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Export state interfaces for the thruster hardware. </p>
<p>This method creates and returns a vector of state interfaces for each thruster joint, as defined in the description/urdf/ROV2026.urdf.xacro. Each interface allows the ROS 2 control framework to read the current effort (state) values from the corresponding thruster.</p>
<dl class="section return"><dt>Returns</dt><dd>std::vector&lt;hardware_interface::StateInterface&gt; A vector containing the state interfaces for all thrusters. </dd></dl>

</div>
</div>
<a id="a2db88eeed2739b0ecac65e528a305b0e" name="a2db88eeed2739b0ecac65e528a305b0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2db88eeed2739b0ecac65e528a305b0e">&#9670;&#160;</a></span>load_parameters()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void rov_control::ThrusterHardwareInterface::load_parameters </td>
          <td>(</td>
          <td class="paramtype">const hardware_interface::HardwareInfo &amp;&#160;</td>
          <td class="paramname"><em>info</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loads hardware info. </p>
<p>This method reads the PWM-related parameters (frequency, minimum, maximum, and midpoint pulse widths) from the provided hardware_interface::HardwareInfo structure. If a parameter is present in the hardware parameters map, its value is parsed and assigned to the corresponding member variable. If a parameter is not present, the existing value (typically the default) is retained.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">info</td><td>The hardware information structure containing hardware parameters. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5dd7f1141ba64dc63975d973ecba7f15" name="a5dd7f1141ba64dc63975d973ecba7f15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5dd7f1141ba64dc63975d973ecba7f15">&#9670;&#160;</a></span>on_activate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">hardware_interface::CallbackReturn rov_control::ThrusterHardwareInterface::on_activate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Activate the thruster hardware interface. </p>
<p>This method is called during the transition from the inactive state to the active state in the ROS 2 lifecycle. It is responsible for preparing the hardware interface to start accepting and executing commands. TODO: Activate or enable hardware.</p>
<dl class="section return"><dt>Returns</dt><dd>hardware_interface::CallbackReturn Returns SUCCESS if activation was successful, ERROR otherwise. </dd></dl>

</div>
</div>
<a id="aaad573b84f1eb13a0dba544a1da5089b" name="aaad573b84f1eb13a0dba544a1da5089b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaad573b84f1eb13a0dba544a1da5089b">&#9670;&#160;</a></span>on_cleanup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">hardware_interface::CallbackReturn rov_control::ThrusterHardwareInterface::on_cleanup </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cleanup the thruster hardware interface. </p>
<p>This method is called during the transition from the inactive state to the unconfigured state in the ROS 2 lifecycle. It resets the command and state vectors to zero and releases any resources allocated during configuration or activation. This prepares the hardware interface for possible reconfiguration or safe shutdown. TODO: Cleanup or release hardware resources in preparation for reconfiguration or shutdown.</p>
<dl class="section return"><dt>Returns</dt><dd>hardware_interface::CallbackReturn Returns SUCCESS if cleanup was successful, ERROR otherwise. </dd></dl>

</div>
</div>
<a id="a8265d068b0e73ab919e96f9bba57ebb1" name="a8265d068b0e73ab919e96f9bba57ebb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8265d068b0e73ab919e96f9bba57ebb1">&#9670;&#160;</a></span>on_configure()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">hardware_interface::CallbackReturn rov_control::ThrusterHardwareInterface::on_configure </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure the thruster hardware interface. </p>
<p>This method is called during the transition from the unconfigured state to the inactive state in the ROS 2 lifecycle. It resets the command and state vectors to zero and prepares the hardware interface for activation. TODO: Initialization or setup hardware required before activation.</p>
<dl class="section return"><dt>Returns</dt><dd>hardware_interface::CallbackReturn Returns SUCCESS if configuration was successful, ERROR otherwise. </dd></dl>

</div>
</div>
<a id="ad5d52c903b9006056b567a28fe402769" name="ad5d52c903b9006056b567a28fe402769"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5d52c903b9006056b567a28fe402769">&#9670;&#160;</a></span>on_deactivate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">hardware_interface::CallbackReturn rov_control::ThrusterHardwareInterface::on_deactivate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deactivate the thruster hardware interface. </p>
<p>This method is called during the transition from the active state to the inactive state in the ROS 2 lifecycle. It is responsible for stopping the hardware interface from accepting and executing commands. We reset the state and command vectors to zero to ensure safe deactivation. TODO: Deactivate or disable hardware.</p>
<dl class="section return"><dt>Returns</dt><dd>hardware_interface::CallbackReturn Returns SUCCESS if deactivation was successful, ERROR otherwise. </dd></dl>

</div>
</div>
<a id="ac3dda9730f55662427cf3f09d1b57280" name="ac3dda9730f55662427cf3f09d1b57280"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3dda9730f55662427cf3f09d1b57280">&#9670;&#160;</a></span>on_error()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">hardware_interface::CallbackReturn rov_control::ThrusterHardwareInterface::on_error </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Handle error state for the thruster hardware interface. </p>
<p>This method is called when the hardware interface enters the error state in the ROS 2 lifecycle. It is responsible for putting the hardware into a safe state, such as stopping all thrusters by setting the command and state vectors to zero, and logging the error. This ensures that the hardware does not continue operating in an unsafe or undefined state after an error has occurred.</p>
<dl class="section return"><dt>Returns</dt><dd>hardware_interface::CallbackReturn Returns ERROR to indicate the hardware is in an error state. </dd></dl>

</div>
</div>
<a id="abbd837b4d214cd05a40588212f4e74c9" name="abbd837b4d214cd05a40588212f4e74c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbd837b4d214cd05a40588212f4e74c9">&#9670;&#160;</a></span>on_init()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">hardware_interface::CallbackReturn rov_control::ThrusterHardwareInterface::on_init </td>
          <td>(</td>
          <td class="paramtype">const hardware_interface::HardwareInfo &amp;&#160;</td>
          <td class="paramname"><em>info</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize the thruster hardware interface with hardware information. </p>
<p>This method is called during the initialization phase of the hardware interface lifecycle. It checks if all required parameters are set and valid by calling the base class implementation. If successful, it initializes the command and state vectors to zero, with a length equal to the number of thruster joints.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">info</td><td>The hardware information structure containing joint and interface definitions. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>hardware_interface::CallbackReturn Returns SUCCESS if initialization was successful, ERROR otherwise. </dd></dl>

</div>
</div>
<a id="a88696bfa332c2b6a308e83c246b0d080" name="a88696bfa332c2b6a308e83c246b0d080"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88696bfa332c2b6a308e83c246b0d080">&#9670;&#160;</a></span>on_shutdown()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">hardware_interface::CallbackReturn rov_control::ThrusterHardwareInterface::on_shutdown </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shutdown the thruster hardware interface. </p>
<p>This method is called during the transition to the finalized (shutdown) state in the ROS 2 lifecycle. It is responsible for safely stopping all thrusters, releasing hardware resources, and resetting the command and state vectors to zero. This ensures the hardware is left in a safe state before the node is destroyed or the process exits. TODO: Shutdown hardware.</p>
<dl class="section return"><dt>Returns</dt><dd>hardware_interface::CallbackReturn Returns SUCCESS if shutdown was successful, ERROR otherwise. </dd></dl>

</div>
</div>
<a id="a89faade16e301a5177e417bedcec840d" name="a89faade16e301a5177e417bedcec840d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89faade16e301a5177e417bedcec840d">&#9670;&#160;</a></span>read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">hardware_interface::return_type rov_control::ThrusterHardwareInterface::read </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read the current state of the thruster hardware. </p>
<p>This method updates the internal state vector to reflect the current state of each thruster. Since the ESCs do not provide feedback, the state is set to match the last command sent. This allows the ROS 2 control framework to assume the thrusters are following the commanded values.</p>
<dl class="section return"><dt>Returns</dt><dd>hardware_interface::return_type Returns OK after updating the state. </dd></dl>

</div>
</div>
<a id="aa1c4bb7d35ff1dfc0696c262d75a34c5" name="aa1c4bb7d35ff1dfc0696c262d75a34c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1c4bb7d35ff1dfc0696c262d75a34c5">&#9670;&#160;</a></span>write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">hardware_interface::return_type rov_control::ThrusterHardwareInterface::write </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write the current command values to the thruster hardware. </p>
<p>This method sends the command values stored in the internal command vector to the thruster hardware. For each thruster, the corresponding command value is converted to PCA9685 ticks using the configured PWM parameters (min, max, mid pulse widths, and frequency). The pulse is always set to start at the beginning of the PWM cycle (on=0), and the width is set by the calculated ticks value (off=ticks).</p>
<p>The function calls pca9685_write_channel() for each thruster channel:</p><ul>
<li>The third argument (on=0) means the PWM pulse starts at the beginning of the cycle.</li>
<li>The fourth argument (off=ticks) sets the pulse width. If writing to any channel fails, an error is logged and the function returns ERROR. Otherwise, it logs the command sent to each thruster and returns OK.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>hardware_interface::return_type Returns OK after sending the commands, or ERROR if any write fails. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>src/rov_control/include/rov_control/<a class="el" href="thruster__interface_8hpp_source.html">thruster_interface.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
